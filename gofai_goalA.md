# GOFAI Goal Track A (Frontend): Deep NLP + Semantics/Pragmatics + HCI

Focus: English parsing, deep semantic composition, pragmatic/discourse resolution, clarification UX, CPL inspection and user-facing trust surfaces. Backend execution details live in Track B.

This file is a bipartite split of `500_gofai_goal.md` so two workstreams can iterate in parallel. Step numbers match the original plan.

---

## Phase 0 — Charter, Invariants, and Non‑Negotiables (Steps 001–050)

- [x] Step 001 [Infra][HCI] — Write a one-page "GOFAI Music+ product contract" (offline, deterministic, inspectable, undoable) and publish it as a repo doc with explicit non-goals.
- [x] Step 005 [HCI] — Define user-facing trust primitives: **preview**, **diff**, **why**, **undo**, and **scope highlighting** are mandatory in UX.
- [x] Step 009 [HCI] — Decide the default interaction loop: parse → show CPL → ask clarifications if needed → show plan/diff → user applies.
- [x] Step 012 [NLP][Prag] — Specify a formal ambiguity policy: allow underspecified meaning (holes) and require explicit resolution before execution.
- [x] Step 013 [NLP][Sem] — Choose a core semantic representation strategy: typed lambda calculus + event semantics + degree semantics, with MRS-like underspecification for scope.
- [x] Step 014 [Prag] — Choose a discourse model strategy: DRT/SDRT-style discourse referents + rhetorical relations for "and/but/then/after".
- [x] Step 015 [Prag][HCI] — Define the "clarification question" contract (QUD-style): every question must (a) name the ambiguity, (b) offer defaults, (c) show impact.
- [x] Step 018 [HCI] — Define "error shapes" for UI: parse error, unresolved reference, unsatisfied constraint, unsafe plan, missing capability.
- [x] Step 019 [Infra] — Commit to "no magic": any default (e.g., what "darker" means) must be inspectable and user-configurable.
- [x] Step 021 [HCI] — Write 10 canonical user scenarios spanning studio editing, education, live performance, and IP-sensitive workflows.
- [x] Step 026 [Type] — Decide on a "semantic provenance" mechanism: every CPL node retains spans + lexeme IDs + rule IDs that created it.
- [x] Step 028 [Eval] — Create a seed dataset: 200 English instructions with expected CPL (covering scope, constraints, comparatives, anaphora, negation).
- [x] Step 029 [Eval] — Create paraphrase sets for 50 of those instructions (≥5 paraphrases each) to enforce semantic invariance.
- [x] Step 030 [Eval][Prag] — Create an "ambiguity suite" of utterances that must trigger clarification (not allowed to auto-resolve).
- [x] Step 034 [HCI] — Define "preview-first UX": user can inspect plan/diff at every step; auto-apply only in explicitly allowed contexts.
- [x] Step 036 [Prag] — Specify how UI selection participates in pragmatics (deictic "this", "here", "these notes"), including fallbacks when selection is empty.
- [x] Step 037 [Sem] — Specify how contrastive constructions map ("do X but keep Y", "do X without Y") including constraint precedence rules.
- [x] Step 038 [Sem][Prag] — Specify the semantics of "again", "still", "also", "too" as presupposition triggers in edit dialogue.
- [x] Step 039 [Prag] — Specify an implicature/default model (Gricean/QUD): what "keep tempo steady" implies absent explicit BPM changes.
- [x] Step 040 [Infra] — Define a change-control rule: new lexemes/grammar rules require golden tests and ambiguity analysis notes.
- [x] Step 041 [Type] — Decide how musical "entities" are typed: section, range, track/layer, card, param, event selector, deck, board.
- [x] Step 042 [Infra] — Create a "canonical axis catalog" for perceptual axes (energy, lift, brightness, width, intimacy, tension, groove tightness).
- [x] Step 043 [Sem] — Define degree semantics for comparatives ("more lift", "less busy") using axis values and monotonic lever mappings.
- [x] Step 044 [HCI] — Define UI affordances for degrees: sliders, discrete "tiny/small/moderate/large", and explicit numeric overrides.
- [x] Step 049 [HCI] — Define "user preference profiles" for vague words (dark = timbre vs harmony vs register) and how UI edits those profiles.
---

## Phase 1 — Canonical Ontology + Extensible Symbol Tables (Steps 051–100)

- [x] Step 051 [Type][Infra] — Create a GOFAI canon layer: a single SSOT module exporting lexeme IDs, axis IDs, opcode IDs, and normalization rules.
- [x] Step 054 [Type] — Define `EntityRef` types (SectionRef, RangeRef, LayerRef, CardRef, ParamRef, DeckRef, BoardRef) with branded IDs.
- [x] Step 055 [Type] — Define `EventSelector` as a typed predicate language over `Event<P>` (kind, tags, role, pitch range, time range).
- [x] Step 056 [Infra] — Implement a project "symbol table builder" that indexes sections, tracks/layers, cards, decks, and boards by IDs and display names.
- [x] Step 057 [Prag][Type] — Add salience tracking to symbol tables (last-focused section, last-edited layer, current selection) for reference resolution.
- [x] Step 058 [NLP][Sem] — Define a canonical section vocabulary: intro/verse/chorus/bridge/outro + numbered variants + user-defined labels.
- [x] Step 059 [NLP][Sem] — Define a canonical layer vocabulary: drums/kick/snare/hats/bass/pad/lead/vocal + role mappings.
- [x] Step 060 [NLP][Sem] — Define a canonical time vocabulary: bars/beats/ticks, relative phrases ("two bars before"), and timepoint references ("at bar 49").
- [x] Step 071 [Infra] — Document the "entity binding precedence": selection > explicit reference > salience > defaults; add tests for resolution order.
- [x] Step 072 [Prag] — Encode deictic resolution rules ("this section", "these notes") and require a UI selection context for them.
- [x] Step 074 [Sem] — Specify how event-level references surface in language ("the last note", "the downbeats", "every other bar").
- [x] Step 075 [HCI] — Add UI copy guidelines for showing entity bindings ("'that chorus' → Chorus 2 (bars 49–65)").
- [x] Step 076 [Infra] — Create a canonical “domain noun inventory” (bars, hook, motif, voicing, groove, drop, build) with definitions and examples.  Note that it should include nouns from as many music theories and traditions as possible.
- [x] Step 077 [Sem] — Define a “musical object ontology” that distinguishes structure, harmony, rhythm, timbre/production, performance.  Note that it should include ontological objects from as many music theories and traditions as possible.
- [x] Step 078 [Type] — Define typed "targets" for preserve-only-change constraints (preserve melody exact vs functional harmony vs recognizable hook), again aiming for wide scope.
- [x] Step 079 [Prag] — Define a model of "shared plans" (plan recognition) for repeated edits ("do it again but bigger").
- [x] Step 080 [Infra] — Implement a canonical registry of "default interpretations" with user-overridable mappings and versioned provenance.
- [x] Step 084 [HCI] — Define how the UI exposes the current focus stack (board → deck → selection) as an explicit context panel.
- [x] Step 085 [Infra] — Add deterministic fuzzy matching rules for resolving names (same algorithm everywhere; stable tie-breakers; explainable matches).
- [x] Step 092 [Prag] — Specify how temporal adverbs ("now", "then") interact with dialogue state to choose edit targets.
- [x] Step 093 [Prag] — Specify how demonstratives ("that", "those") choose referents using salience, recency, and UI focus.
- [x] Step 094 [Sem] — Define the semantics of coordination and sequencing ("do X and then Y") as ordered plan composition.
- [x] Step 095 [Sem] — Define the semantics of "instead" and "rather than" as plan replacement with explicit rollback.
- [x] Step 096 [HCI] — Design a "binding inspector" UI panel that shows resolved referents and why they were chosen.
- [x] Step 097 [HCI] — Design a "vocabulary browser" UI that lists known terms and their meanings, including extension namespaces.
---

## Phase 2 — Parsing Frontend: Tokenization, Morphology, and Grammar (Steps 101–150)

- [x] Step 101 [NLP] — Implement a span-preserving tokenizer that retains original substrings for quoting, highlighting, and provenance.
- [x] Step 102 [NLP] — Implement a normalizer that canonicalizes whitespace, punctuation, unicode quotes, hyphenation, and common unit spellings.
- [x] Step 103 [NLP] — Implement morphological normalization (lemmatization-lite) for core verbs/adjectives (tighten/tighter/tightening).
- [x] Step 104 [NLP] — Add a robust number parser (words + digits) supporting "two", "a couple", "half", and numeric ranges.
- [x] Step 105 [NLP] — Implement unit parsing ("96 BPM", "+7 semitones", "two bars"), returning typed units.
- [x] Step 106 [NLP][Infra] — Choose and implement a deterministic parsing engine (Earley/GLR + scoring, or PEG + diagnostics) and document tradeoffs.
- [x] Step 107 [NLP] — Add a parse forest representation to preserve ambiguity instead of losing it to early decisions.
- [x] Step 108 [NLP][Prag] — Implement a scoring model for parse selection that prefers explicit scopes and safer interpretations.
- [x] Step 109 [NLP] — Implement parse diagnostics ("why this parse won") to support developer debugging and user-facing explanations.
- [x] Step 110 [NLP] — Implement incremental parsing hooks for "parse while typing" with caching keyed by token spans.
- [x] Step 111 [NLP][Sem] — Add a grammar for imperatives ("make", "add", "remove", "keep", "switch") with typed verb frames.
- [x] Step 112 [NLP][Sem] — Add a grammar for comparatives and degree modifiers ("more", "less", "slightly", "a lot").
- [x] Step 113 [NLP][Sem] — Add a grammar for coordination ("X and Y", "X but Y", "X then Y") preserving rhetorical structure cues.
- [x] Step 114 [NLP][Sem] — Add a grammar for negation and exclusion ("don't", "no", "without", "except") with explicit scope.
- [x] Step 115 [NLP] — Add a grammar for time expressions ("for 8 bars", "before the last chorus", "in verse 2") that builds typed ranges.
- [x] Step 116 [NLP][Prag] — Add a grammar for reference expressions (pronouns, demonstratives, "same as before") that produce unresolved referents.
- [x] Step 117 [NLP][Sem] — Add a grammar for quantification ("all choruses", "every other bar", "each verse") producing selection predicates.
- [x] Step 118 [NLP][Sem] — Add a grammar for modality and permission ("try", "maybe", "if possible") producing soft constraints or alternative plans.
- [x] Step 119 [NLP][Sem] — Add a grammar for questions ("what chords are in the chorus?", "why did you change that?") mapping to inspect/explain acts.
- [x] Step 120 [NLP][Sem] — Add a grammar for explicit user-defined names ("the 'glass pad' track") supporting quoted referents.
- [x] Step 121 [NLP][Sem] — Add lexeme classes for musical roles (melody, bassline, hook, accompaniment) with selectional restrictions.
- [x] Step 122 [NLP][Sem] — Add lexeme classes for musical objects (chords, voicings, rhythm, groove, density, register) with semantic mappings.
- [x] Step 123 [NLP][Sem] — Add lexeme classes for production terms (width, brightness, punch) that map either to arrangement levers or DSP levers.
- [x] Step 124 [NLP] — Add a grammar for "edit locality" ("just", "only", "at least") to bias cost model and scope.
- [x] Step 125 [NLP][Sem] — Add a grammar for "preservation" ("keep the chords", "don't change the melody") generating explicit CPL preserve constraints.
- [x] Step 126 [NLP] — Add a robust "unknown token" strategy that preserves unknown terms as candidate entity names rather than failing parsing.
- [x] Step 127 [NLP][Ext] — Add a mechanism for extensions to register additional lexemes and lexical variants into the parser at runtime.
- [x] Step 128 [NLP][Ext] — Add a mechanism for extensions to register new grammar rules with rule IDs, priorities, and required tests.
- [x] Step 129 [NLP][Infra] — Add a grammar regression harness that can snapshot parse forests and detect unintended ambiguity explosions.
- [x] Step 130 [NLP][HCI] — Add a user-facing "I didn't understand" error formatter that pinpoints spans and suggests known terms.
- [x] Step 131 [Sem] — Implement argument structure constraints: ensure verbs like "widen" modify width-like targets, not arbitrary nouns (selectional restrictions).
- [x] Step 132 [Sem] — Implement type-directed disambiguation (bidirectional typing): use expected CPL node types to prune parse candidates.
- [x] Step 133 [Sem] — Implement compositional semantics hooks per grammar rule to produce intermediate meaning (CPL holes allowed).
- [x] Step 134 [Sem] — Implement "construction grammar" style templates for music-specific phrasings ("make it hit harder", "bring it in earlier").
- [x] Step 135 [Sem] — Implement degree semantics for vague adjectives ("warmer", "darker") as axis changes with candidate interpretations.
- [x] Step 136 [Sem] — Implement event semantics for actions ("add", "remove", "change") to uniformly represent edit events and their arguments.
- [x] Step 137 [Sem] — Implement generalized quantifier semantics for "all/some/most" when needed for selectors ("all choruses").
- [x] Step 138 [Sem] — Implement a representation for scope ambiguity (MRS-style) when quantifiers, negation, and "only" interact.
- [x] Step 139 [Prag] — Implement a "pragmatic bias" layer that pushes ambiguous parses into clarification rather than unsafe execution.
- [x] Step 140 [Infra] — Add developer tooling to visualize parse forest + semantic composition for a given utterance.
- [x] Step 141 [Eval] — Add golden tests for 100 core utterances ensuring stable tokenization and parse outputs.
- [x] Step 142 [Eval] — Add paraphrase invariance tests at the parse+semantics boundary (paraphrases should yield the same CPL-Intent or same holes).
- [x] Step 143 [Eval] — Add fuzz tests for tokenizer and unit parsing (random punctuation, unicode, spacing) to ensure robustness.
- [x] Step 144 [Eval] — Add ambiguity tests ensuring known ambiguous utterances do not collapse to a single meaning without clarification.
- [x] Step 145 [Eval] — Add performance tests for parsing latency under incremental typing (budget targets per input length).
- [x] Step 146 [HCI] — Define a "typing UX" spec: parse status indicator, suggestions dropdown, and how/when to interrupt with clarification.
- [x] Step 147 [HCI] — Define an error recovery UX: user can edit the utterance, accept suggested rephrasing, or choose from interpreted candidates.
- [x] Step 148 [HCI] — Add UI copy templates for clarification questions ("By 'darker' do you mean timbre, harmony, register, or texture?").
- [x] Step 149 [HCI] — Add a rule that every clarification UI must show a default and "why this matters" in one line.
- [x] Step 150 [Infra] — Establish a "grammar authorship workflow" (PR checklist: add lexeme, add grammar rule, add golden tests, add docs entry).
---

## Phase 3 — Deep Semantics: From Syntax to CPL (Steps 151–200)

- [x] Step 151 [Type][Sem] — Define the CPL AST family as three layers: CPL-Intent, CPL-Plan, CPL-Host, each with versioned JSON encoding.
- [x] Step 152 [Type][Sem] — Define `CPLHole` nodes explicitly (unknown axis sense, unknown referent, unknown amount, unknown scope) with candidate sets.
- [x] Step 153 [Type][Sem] — Define `SpeechAct` types (change, inspect, explain, undo/redo, propose) and make them the root of CPL-Intent.
- [x] Step 154 [Sem] — Encode neo-Davidsonian event semantics for edits: edit actions are events with thematic roles (agent=user, patient=target).
- [x] Step 155 [Sem] — Encode degree semantics for axes and comparatives; represent "more" as an ordering constraint on an axis variable.
- [x] Step 156 [Sem] — Add a Montague-style compositional pipeline: parse rules attach lambda terms that assemble into CPL-Intent skeletons.
- [x] Step 157 [Sem] — Add FrameNet/Frame semantics integration: verb frames ("tighten", "widen", "simplify") map to axis/levers + selectional restrictions.
- [x] Step 158 [Sem] — Add a typed representation for "musical goals" distinct from "actions": goals are desiderata over axes and structures.
- [x] Step 159 [Sem] — Add a typed representation for "constraints" that can be checked against diffs (preserve melody exact, keep chords functional).
- [x] Step 160 [Sem] — Add a typed representation for "preferences" (least-change, no-new-layers) as weighted soft constraints.
- [x] Step 161 [Sem] — Implement contrast semantics for "but" (SDRT cue): represent as goal+constraint pairing with discourse relation `Contrast`.
- [x] Step 162 [Sem] — Implement sequencing semantics for "then/after/before" as plan composition constraints (order in CPL-Plan).
- [x] Step 163 [Sem] — Implement "only" semantics: a focus-sensitive operator that restricts the allowed change targets.
- [x] Step 164 [Sem] — Implement "still" and "again" semantics as presuppositions about prior states/edits (ties into edit history).
- [x] Step 165 [Sem] — Implement "keep X the same" as `preserve(X, exact)` by default, with optional relaxation to functional/recognizable modes.
- [x] Step 166 [Sem][Type] — Define `PreservationMode` = exact | functional | recognizable, and specify validation checks for each (pitch equality vs contour fingerprint).
- [x] Step 167 [Sem] — Add motif identity semantics: define motif fingerprints (interval/rhythm) and "recognizable" thresholds.
- [x] Step 168 [Sem] — Add harmony identity semantics: define chord skeleton vs extensions vs substitutions; map "keep chords" to an explicit tier.
- [x] Step 169 [Sem] — Add rhythm identity semantics: define "keep rhythm" as onset grid equality or tolerance-based equivalence.
- [x] Step 170 [Sem] — Add arrangement identity semantics: define "keep instrumentation" vs "keep roles" vs "keep layers" as distinct constraints.
- [x] Step 171 [Sem][Type] — Implement "semantic typing" for scopes: section scopes accept section refs; bar-range scopes accept typed ranges; selectors accept predicates.
- [x] Step 172 [Sem][Type] — Implement "semantic typing" for targets: axis modifiers must attach to axes or to entities with known axis bindings.
- [x] Step 173 [Sem] — Implement semantics for "make it feel X" as mapping from affective adjectives to axis bundles + candidate levers (explicitly namespaced).
- [x] Step 174 [Sem] — Implement semantics for "hit harder"/"more punch" as mapping to impact axis + candidate levers (density, transients, dynamics).
- [x] Step 175 [Sem] — Implement semantics for "more hopeful" as mapping to tension/release + brightness + register (with explicit constraints interaction).
- [x] Step 176 [Sem] — Build a "meaning provenance graph" that can explain which words mapped to which CPL nodes and why.
- [x] Step 177 [Sem] — Implement MRS-like underspecification for scope ambiguities; keep an explicit set of constraints instead of choosing prematurely.
- [x] Step 178 [Sem] — Implement a scope resolution phase that either (a) resolves safely by rules or (b) produces a clarification question.
- [x] Step 179 [Sem] — Implement typed ellipsis templates ("same but bigger", "do that again") as transformations over prior CPL/plan nodes.
- [x] Step 180 [Sem] — Implement typed metonymy handling for music talk ("the chorus" can mean section events, harmony, or arrangement) as a hole with candidates.
- [x] Step 181 [Type] — Define a "CPL well-formedness checker" that rejects missing required fields and unknown tags/opcodes/axes.
- [x] Step 182 [Type] — Define a "CPL effect checker" that ensures `inspect` requests cannot compile to mutation actions.
- [x] Step 183 [Type] — Define a "CPL capability checker" that blocks compilation requiring disabled capabilities (e.g., production edits on non-production boards).
- [x] Step 184 [Type] — Add refinement validations for numeric fields (BPM, semitones, amount) with consistent error messages.
- [x] Step 185 [Type] — Implement bidirectional typechecking between grammar semantics and CPL AST types (catch lexeme mapping errors early).
- [x] Step 186 [NLP][Sem] — Add support for quoted programmatic references ("the track called 'Glass Pad'") and ensure they bind deterministically.
- [x] Step 187 [NLP][Sem] — Add support for adjectival stacks ("brighter and wider and less busy") as conjunction of goals with shared scope.
- [x] Step 188 [NLP][Sem] — Add support for nested scopes ("in the chorus, on the drums, only for two bars") producing compositional scope nodes.
- [x] Step 189 [NLP][Sem] — Add support for numeric qualifiers ("raise it 2 semitones", "reduce density by 20%") with typed units.
- [x] Step 190 [NLP][Sem] — Add support for range expressions ("bars 33–40", "last 2 bars") with inclusive/exclusive rules documented.
- [x] Step 191 [Eval] — Add golden tests for CPL-Intent construction for 200 utterances with explicit expected holes where ambiguity exists.
- [x] Step 192 [Eval] — Add "semantic diff" tests: ensure changes to lexicon mappings don't silently change CPL outputs without updating goldens.
- [x] Step 193 [Eval] — Add "scope safety" tests: utterances with scoping must always bind to the same range given the same fixture.
- [x] Step 194 [Eval] — Add "operator interaction" tests for negation/only/quantifiers, ensuring MRS underspecification behaves predictably.
- [x] Step 195 [Eval] — Add tests ensuring presupposition triggers create expected "requires prior referent" holes when history lacks support.
- [x] Step 196 [HCI] — Define a CPL viewer UX: collapsible tree, colored tags (goal/constraint/scope), and clickable spans back to original text.
- [x] Step 197 [HCI] — Add an "ambiguity UI" pattern: show candidate meanings side-by-side with consequences; allow default selection.
- [x] Step 198 [HCI] — Add a "semantic provenance UI" pattern: hover on CPL node to show source words + rule IDs in developer mode.
- [x] Step 199 [HCI] — Add a "user vocabulary learning" UX: when user clarifies "dark means timbre", offer to save as preference.
- [x] Step 200 [HCI] — Add a "teach mode" option: the system can explain the semantics in musical terms (education workflow).
---

## Phase 4 — Deep Pragmatics + Dialogue: Context, Anaphora, Presupposition, QUD (Steps 201–250)

- [x] Step 201 [Prag] — Define a dialogue state model that stores: last focused scope, salient entities, last CPL, last plan, last diff, user prefs.
- [x] Step 202 [Prag] — Implement DRT-style discourse referents for entities (sections, layers, cards, motifs) that persist across turns.
- [x] Step 203 [Prag] — Implement anaphora resolution rules for "it/that/this/there" using salience + UI focus + recency weighting.
- [x] Step 204 [Prag] — Implement definite description resolution ("the chorus", "the bridge") with ambiguity to clarification when multiple matches exist.
- [x] Step 205 [Prag] — Implement demonstrative resolution tied to UI selection ("these notes") with fallback to last selection.
- [x] Step 206 [Prag] — Implement presupposition checking/accommodation for "again", "still", "back", "return", "keep", and "continue".
- [x] Step 207 [Prag] — Implement conversational implicature defaults: "make it tighter" defaults to microtiming and density levers unless user overrides.
- [x] Step 208 [Prag] — Implement QUD stack tracking: interpret utterances relative to the current question under discussion to decide what "it" refers to.
- [x] Step 209 [Prag] — Implement clarification generation as QUD refinement: questions should reduce candidate set cardinality maximally.
- [x] Step 210 [Prag] — Implement "accept defaults" and "override" dialogue moves ("yes", "no, I meant harmony") as edits to holes.
- [x] Step 211 [Prag] — Implement ellipsis resolution ("same but bigger") by referencing the last plan step or last edit package as antecedent.
- [x] Step 212 [Prag] — Implement modal subordination-like behavior for "if possible" (store conditional intent and prefer satisfying it).
- [x] Step 213 [Prag] — Implement a "common ground" model: track what has been mutually established (selected chorus = Chorus 2) to stabilize references.
- [x] Step 214 [Prag] — Implement discourse relations (SDRT) for "but/so/then/also" to shape plan ordering and constraint emphasis.
- [x] Step 215 [Prag] — Implement repair moves: user can say "no, not that chorus" and the system rebinds referent without losing other meaning.
- [x] Step 216 [Prag] — Implement temporal deixis: interpret "earlier/later" relative to (a) song form or (b) bar microtiming as an explicit ambiguity.
- [x] Step 217 [Prag] — Implement scale of granularity: interpret "earlier" as section-level vs beat-level depending on context (default to safer clarification).
- [x] Step 218 [Prag] — Implement "topic continuity": if user is working on chorus, "make it wider" inherits chorus scope unless contradicted.
- [x] Step 219 [Prag] — Implement "focus semantics": contrastive stress (if captured) or textual cues ("NOT the chords") prioritize certain constraints.
- [x] Step 220 [Prag] — Implement "reference by description": "the noisy synth" resolves via metadata/tags; if multiple, ask a disambiguating question.
- [x] Step 221 [Prag][Type] — Typecheck pragmatic bindings: references must resolve to entities compatible with their semantic roles or become holes.
- [x] Step 222 [Prag][Type] — Define a structured "clarification object" type: question text, options, default, effect on CPL, and safety notes.
- [x] Step 223 [Prag] — Implement a "clarification minimality" principle: ask only what's needed to execute safely, not what's needed to be perfect.
- [x] Step 224 [Prag] — Implement a "clarification batching" strategy: combine related ambiguities into one UI step when possible.
- [x] Step 225 [Prag] — Implement user preference learning: persist mapping preferences for vague terms and apply them with provenance ("using your default").
- [x] Step 226 [Sem][Prag] — Model speech acts explicitly: distinguish requests, suggestions, questions, meta-questions ("why"), and commands to undo.
- [x] Step 227 [Prag] — Implement politeness/hedging handling ("could you maybe") as lowering confidence, not changing the semantic act type.
- [x] Step 228 [Prag] — Implement "intention recognition" for multi-turn editing: recognize that user is optimizing a section and keep stable scope.
- [x] Step 229 [Prag] — Implement "plan confirmation" moves: user says "yes, do that" to commit and execute; nothing executes before that.
- [x] Step 230 [Prag] — Implement "counterfactual exploration": user says "what if we…" to produce alternative plans without mutation.
- [ ] Step 231 [HCI] — Add UI for “clarification cards”: each ambiguity is a small card with radio options and a default explanation.
- [ ] Step 232 [HCI] — Add UI for “context strip”: shows current focus (board/deck/section/range/layer) and how pronouns will resolve.
- [ ] Step 233 [HCI] — Add UI for “conversation memory”: show last N turns with CPL and diffs; allow bookmarking.
- [ ] Step 234 [HCI] — Add UI for “undo target selection”: user can undo last, undo specific package, or undo by scope (chorus only).
- [ ] Step 235 [HCI] — Add UI for “preference tuning”: user can set “dark means…” via a simple toggle matrix.
- [ ] Step 236 [Eval] — Create a dialogue fixture suite: multi-turn conversations with expected referent bindings and clarifications.
- [ ] Step 237 [Eval] — Add tests for anaphora correctness across turns (it/that/again) using DRT-style referents.
- [ ] Step 238 [Eval] — Add tests for presupposition handling: “again” must fail/clarify if no antecedent edit exists.
- [ ] Step 239 [Eval] — Add tests for QUD behavior: clarification questions should reduce ambiguity and not introduce new ambiguities.
- [ ] Step 240 [Eval] — Add regression tests for “repair moves” (“no, I meant…”) preserving all other semantics.
- [ ] Step 241 [Sem][Prag] — Integrate discourse-level constraints: “but keep the melody” should become a high-priority hard constraint by default.
- [ ] Step 242 [Sem][Prag] — Implement “accommodation policies” for underspecified requests: propose defaults but require explicit acknowledgement before execution.
- [ ] Step 243 [Prag] — Implement “safety-first deference”: if a binding would cause large changes, prefer asking a question over executing.
- [ ] Step 244 [Prag] — Implement “confidence” as an internal measure derived from ambiguity/hole count, not as a probabilistic model.
- [ ] Step 245 [Prag] — Implement “explainable resolution”: every resolved pronoun must have a user-readable reason (“most recent focus: Chorus 2”).
- [ ] Step 246 [HCI] — Add “why this question?” affordance on clarification UI that shows the competing meanings and their edits.
- [ ] Step 247 [HCI] — Add a “safe preview mode” for ambiguous requests: show two candidate diffs without applying either.
- [ ] Step 248 [HCI] — Add a “commit button” that is disabled until all hard ambiguities are resolved (holes that affect execution).
- [ ] Step 249 [HCI] — Add “developer mode” toggles to display discourse referents and salience scores for debugging.
- [ ] Step 250 [Infra] — Define an internal “pragmatics trace” format that records binding decisions for reproducibility and bug reports.
---

## Phase 7 — HCI: The GOFAI Deck, Clarifications, Trust, and Flow (Steps 351–400)

- [ ] Step 351 [HCI] — Implement a GOFAI deck UI with three panes: English input, CPL viewer, Plan/Diff preview, aligned with CardPlay deck patterns.
- [ ] Step 352 [HCI] — Add inline scope visualization: hovering “chorus” highlights the bound section in the timeline and editors.
- [ ] Step 353 [HCI] — Add inline entity chips: resolved referents appear as chips (“Chorus 2”, “Drums track”) that can be clicked to change binding.
- [ ] Step 354 [HCI] — Add “apply” gating UI: disabled until required clarifications resolved and plan preflight passes.
- [ ] Step 355 [HCI] — Add a “quick actions” bar: undo, redo, explain, compare plans, export report.
- [ ] Step 356 [HCI] — Implement a dedicated clarification modal that supports QUD-style options with defaults and consequences.
- [ ] Step 357 [HCI] — Provide an “ask fewer questions” toggle that allows the user to set stronger defaults (with safety warnings).
- [ ] Step 358 [HCI] — Provide a “strict mode” toggle for studios: always clarify ambiguous terms; never auto-default.
- [ ] Step 359 [HCI] — Implement keyboard-first workflows: enter command, navigate clarifications, apply, undo, all without mouse.
- [ ] Step 360 [HCI] — Implement accessibility semantics (ARIA labels, focus management, screen reader-friendly diff summaries).
- [ ] Step 361 [HCI] — Add a “plan comparison” UI: show two candidate plans with side-by-side diff summaries and lever explanations.
- [ ] Step 362 [HCI] — Add a “lever editing” UI: user can tweak plan parameters (amounts, ranges) before apply and revalidate.
- [ ] Step 363 [HCI] — Add a “scope editing” UI: user can expand/narrow scope via timeline brushing; CPL updates live.
- [ ] Step 364 [HCI] — Add “safety badges” (safe/medium/risky) derived from cost model + constraint risk; show why in tooltip.
- [ ] Step 365 [HCI] — Add “explanation mode” where the tool narrates musical reasoning (“Raised register to increase lift”).
- [ ] Step 366 [HCI] — Integrate the GOFAI deck into board gating: only visible in boards whose tool config allows it; otherwise parse-only in a minimal panel.
- [ ] Step 367 [HCI] — Add a “board recommendation” action: if a request requires tools not available, suggest switching boards rather than failing.
- [ ] Step 368 [HCI] — Add UI for “capability mismatches” (e.g., production edits requested but production tools disabled): show alternatives.
- [ ] Step 369 [HCI] — Add UI for “inspect requests” (show chords, show density): results display in a structured viewer, not chat text.
- [ ] Step 370 [HCI] — Add “bookmarking” and “naming” of edit packages (“Chorus lift v3”), and allow quick revert to bookmarks.
- [ ] Step 371 [HCI] — Implement a “confidence timeline”: show how confidence changes as the user clarifies and refines.
- [ ] Step 372 [HCI] — Implement “show me what you understood” as a dedicated action that displays CPL and bindings even before planning.
- [ ] Step 373 [HCI] — Implement “teach me” explanations: the system can explain chord functions, groove changes, and why a plan increases tension.
- [ ] Step 374 [HCI] — Implement “collaboration export”: generate a shareable markdown/JSON report of edits without including sensitive assets.
- [ ] Step 375 [HCI] — Implement “undo/redo UX parity”: undo and redo should show the same diff previews as apply.
- [ ] Step 376 [HCI] — Implement error affordances: parse errors highlight spans; unsatisfied constraints show counterexamples; missing referents show binding suggestions.
- [ ] Step 377 [HCI] — Implement “safe degrade”: when a request is too broad, the UI offers narrower scopes or proposes inspection first.
- [ ] Step 378 [HCI] — Implement “user intent editing”: allow directly editing CPL nodes (advanced mode) while preserving provenance of manual edits.
- [ ] Step 379 [HCI] — Implement “developer inspector mode”: show parse forest, MRS constraints, discourse referents, plan scoring details.
- [ ] Step 380 [HCI] — Implement “profile UX”: per-user defaults for vague terms and safety level; allow exporting/importing profiles.
- [ ] Step 381 [HCI] — Add a “vocabulary hinting” UX: as user types, suggest known axes/entities (“lift”, “chorus 2”, “hats”).
- [ ] Step 382 [HCI] — Add “did you mean…” corrections for unknown terms based on lexicon and symbol tables.
- [ ] Step 383 [HCI] — Add “inline plan preview” for simple requests (single lever), showing immediate diff proposals.
- [ ] Step 384 [HCI] — Add “plan staging”: user can queue multiple edits and apply as a single package, with combined diff.
- [ ] Step 385 [HCI] — Add “guard rails” for destructive edits: large structural changes require extra confirmation UI.
- [ ] Step 386 [Eval][HCI] — Run formative usability tests on the clarification UI with musicians; measure confusion points and iterate.
- [ ] Step 387 [Eval][HCI] — Measure time-to-completion for common edits vs manual DAW-like operations; track deltas.
- [ ] Step 388 [Eval][HCI] — Measure “trust metrics”: frequency of undo, frequency of plan preview usage, and user-reported confidence.
- [ ] Step 389 [Eval][HCI] — Run A/B tests (local) for different explanation formats (lever-based vs narrative) and measure comprehension.
- [ ] Step 390 [Eval][HCI] — Validate accessibility with keyboard-only and screen reader testing; add tests for focus traps.
- [ ] Step 391 [HCI] — Implement onboarding: guided tutorial that teaches scopes, constraints, and how clarifications work.
- [ ] Step 392 [HCI] — Implement tooltips and inline examples for common commands (“cut drums for two bars before last chorus”).
- [ ] Step 393 [HCI] — Implement “command templates” as chips that insert structured phrases (reduces parse errors).
- [ ] Step 394 [HCI] — Implement “status bar” showing current parse state (ok / ambiguous / needs entity / needs capability).
- [ ] Step 395 [HCI] — Implement “power user shortcuts” (jump to CPL view, jump to diff view, jump to bindings inspector).
- [ ] Step 396 [HCI] — Implement “progressive disclosure”: novices see simplified CPL; experts can expand into full typed structure.
- [ ] Step 397 [HCI] — Implement “explain constraints” UI: show exactly which constraint checks were run and their outcomes.
- [ ] Step 398 [HCI] — Implement “plan safety summary” UI: small table listing touched scopes/layers/cards and preserved invariants.
- [ ] Step 399 [HCI] — Implement “offline reassurance” UI: show that no network is used and assets remain local.
- [ ] Step 400 [Infra] — Add UX instrumentation (local, optional) to capture parse failures and clarification frequency for iterative improvement.

**Step count:** 250
